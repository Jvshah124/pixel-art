<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pixel Art Creator | Built by Jv Shah</title>
  <style>
    body {
      font-family: 'Courier New', monospace;
      background: #f0f0f0;
      margin: 0;
      padding: 20px;
      text-align: center;
    }
    
    h1 {
      color: #333;
    }
    
    #toolbar {
      margin: 20px auto;
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    button, select, input {
      padding: 8px 12px;
      background: white;
      border: 2px solid #333;
      font-family: inherit;
      cursor: pointer;
    }
    
    button:hover {
      background: #333;
      color: white;
    }
    
    #color-picker {
      width: 50px;
      height: 30px;
      padding: 0;
      border: 2px solid #333;
    }
    
    #palette-container {
      display: flex;
      justify-content: center;
      gap: 5px;
      margin: 10px 0;
      flex-wrap: wrap;
    }
    
    .palette-color {
      width: 24px;
      height: 24px;
      border: 2px solid #333;
      cursor: pointer;
    }
    
    #canvas-container {
      margin: 0 auto;
      display: inline-block;
      background: white;
      box-shadow: 0 0 10px rgba(0,0,0,0.2);
      position: relative;
    }
    
    #pixel-canvas {
      display: block;
      image-rendering: pixelated;
      cursor: crosshair;
    }
    
    #animation-timeline {
      margin: 20px auto;
      display: flex;
      overflow-x: auto;
      gap: 5px;
      max-width: 800px;
    }
    
    .animation-frame {
      border: 2px solid #333;
      background: white;
    }
    
    .copyright {
      position: fixed;
      bottom: 12px;
      right: 12px;
      font-family: monospace;
      color: #666;
      background: rgba(255, 255, 255, 0.7);
      padding: 4px 8px;
      border-radius: 4px;
    }
    
    .copyright a {
      color: #FF6B00;
      text-decoration: none;
    }
    
    .copyright a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <h1>Pixel Art Creator - Jv Shah</h1>
  
  <div id="toolbar">
    <select id="grid-size">
      <option value="8">8x8</option>
      <option value="16" selected>16x16</option>
      <option value="32">32x32</option>
      <option value="64">64x64</option>
    </select>
    
    <input type="color" id="color-picker" value="#FF0000">
    
    <select id="tool-select">
      <option value="pencil" selected>Pencil</option>
      <option value="fill">Fill</option>
      <option value="erase">Erase</option>
    </select>
    
    <select id="palette-select">
      <option value="custom">Custom</option>
      <option value="nes">NES</option>
      <option value="gameboy">Game Boy</option>
      <option value="pico8">PICO-8</option>
      <option value="cga">CGA</option>
    </select>
    
    <button id="clear-btn">Clear</button>
    <button id="undo-btn">Undo (Ctrl+Z)</button>
    <button id="redo-btn">Redo (Ctrl+Y)</button>
    <button id="add-frame-btn">Add Frame</button>
    <button id="export-png-btn">Export PNG</button>
    <button id="export-gif-btn">Export GIF</button>
  </div>
  
  <div id="palette-container"></div>
  
  <div id="canvas-container">
    <canvas id="pixel-canvas" width="320" height="320"></canvas>
  </div>
  
  <div id="animation-timeline"></div>
  
  <footer class="copyright">
    Built by <a href="https://x.com/JvShah124" target="_blank" rel="noopener">Jv Shah</a>
  </footer>

  <script>
    // Core variables
    const canvas = document.getElementById('pixel-canvas');
    const ctx = canvas.getContext('2d');
    let currentColor = '#FF0000';
    let currentTool = 'pencil';
    let gridSize = 16;
    let cellSize = canvas.width / gridSize;
    let frames = [];
    let currentFrame = 0;
    
    // Undo/redo stacks
    let undoStack = [];
    let redoStack = [];
    
    // Predefined palettes
    const palettes = {
      custom: [],
      nes: ['#7C7C7C', '#0000FC', '#0000BC', '#4428BC', '#940084', '#A80020', '#A81000', '#881400', '#503000', '#007800', '#006800', '#005800', '#004058', '#000000', '#000000', '#000000'],
      gameboy: ['#0F380F', '#306230', '#8BAC0F', '#9BBC0F'],
      pico8: ['#000000', '#1D2B53', '#7E2553', '#008751', '#AB5236', '#5F574F', '#C2C3C7', '#FFF1E8', '#FF004D', '#FFA300', '#FFEC27', '#00E436', '#29ADFF', '#83769C', '#FF77A8', '#FFCCAA'],
      cga: ['#000000', '#55FFFF', '#FF55FF', '#FFFFFF']
    };
    
    // Initialize
    initCanvas();
    updatePaletteDisplay();
    
    // Event listeners
    document.getElementById('color-picker').addEventListener('input', (e) => {
      currentColor = e.target.value;
      document.getElementById('palette-select').value = 'custom';
      updatePaletteDisplay();
    });
    
    document.getElementById('tool-select').addEventListener('change', (e) => {
      currentTool = e.target.value;
    });
    
    document.getElementById('grid-size').addEventListener('change', (e) => {
      gridSize = parseInt(e.target.value);
      cellSize = canvas.width / gridSize;
      initCanvas();
    });
    
    document.getElementById('palette-select').addEventListener('change', (e) => {
      updatePaletteDisplay();
    });
    
    document.getElementById('clear-btn').addEventListener('click', () => {
      saveToUndoStack();
      frames[currentFrame] = createBlankFrame();
      drawCurrentFrame();
    });
    
    document.getElementById('undo-btn').addEventListener('click', undo);
    document.getElementById('redo-btn').addEventListener('click', redo);
    document.getElementById('add-frame-btn').addEventListener('click', () => {
      saveToUndoStack();
      frames.push(createBlankFrame());
      currentFrame = frames.length - 1;
      updateTimeline();
      drawCurrentFrame();
    });
    
    document.getElementById('export-png-btn').addEventListener('click', exportPNG);
    document.getElementById('export-gif-btn').addEventListener('click', exportGIF);
    
    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey) {
        if (e.key === 'z') {
          e.preventDefault();
          undo();
        } else if (e.key === 'y') {
          e.preventDefault();
          redo();
        }
      }
    });
    
    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseout', stopDrawing);
    
    // Core functions
    function initCanvas() {
      frames = [createBlankFrame()];
      currentFrame = 0;
      undoStack = [];
      redoStack = [];
      drawCurrentFrame();
      updateTimeline();
    }
    
    function createBlankFrame() {
      const frame = [];
      for (let i = 0; i < gridSize * gridSize; i++) {
        frame.push('#FFFFFF');
      }
      return frame;
    }
    
    function drawCurrentFrame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw grid
      ctx.strokeStyle = '#EEE';
      ctx.lineWidth = 1;
      
      for (let x = 0; x <= gridSize; x++) {
        ctx.beginPath();
        ctx.moveTo(x * cellSize, 0);
        ctx.lineTo(x * cellSize, canvas.height);
        ctx.stroke();
      }
      
      for (let y = 0; y <= gridSize; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * cellSize);
        ctx.lineTo(canvas.width, y * cellSize);
        ctx.stroke();
      }
      
      // Draw pixels
      frames[currentFrame].forEach((color, index) => {
        if (color !== '#FFFFFF') {
          const x = index % gridSize;
          const y = Math.floor(index / gridSize);
          ctx.fillStyle = color;
          ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
        }
      });
    }
    
    // Drawing logic
    let isDrawing = false;
    let lastDrawnIndex = -1;
    
    function startDrawing(e) {
      isDrawing = true;
      saveToUndoStack();
      draw(e);
    }
    
    function draw(e) {
      if (!isDrawing) return;
      
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / cellSize);
      const y = Math.floor((e.clientY - rect.top) / cellSize);
      
      if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
        const index = y * gridSize + x;
        
        // Skip if drawing on same pixel continuously
        if (index === lastDrawnIndex && currentTool !== 'fill') return;
        lastDrawnIndex = index;
        
        switch (currentTool) {
          case 'pencil':
            frames[currentFrame][index] = currentColor;
            break;
          case 'erase':
            frames[currentFrame][index] = '#FFFFFF';
            break;
          case 'fill':
            floodFill(x, y, frames[currentFrame][index], currentColor);
            break;
        }
        
        drawCurrentFrame();
      }
    }
    
    function stopDrawing() {
      isDrawing = false;
      lastDrawnIndex = -1;
    }
    
    // Flood fill algorithm
    function floodFill(x, y, targetColor, replacementColor) {
      if (targetColor === replacementColor) return;
      
      const index = y * gridSize + x;
      if (frames[currentFrame][index] !== targetColor) return;
      
      frames[currentFrame][index] = replacementColor;
      
      if (x > 0) floodFill(x - 1, y, targetColor, replacementColor);
      if (x < gridSize - 1) floodFill(x + 1, y, targetColor, replacementColor);
      if (y > 0) floodFill(x, y - 1, targetColor, replacementColor);
      if (y < gridSize - 1) floodFill(x, y + 1, targetColor, replacementColor);
    }
    
    // Palette functions
    function updatePaletteDisplay() {
      const paletteContainer = document.getElementById('palette-container');
      paletteContainer.innerHTML = '';
      
      const selectedPalette = document.getElementById('palette-select').value;
      const colors = palettes[selectedPalette];
      
      if (colors && colors.length > 0) {
        colors.forEach(color => {
          const colorDiv = document.createElement('div');
          colorDiv.className = 'palette-color';
          colorDiv.style.backgroundColor = color;
          colorDiv.addEventListener('click', () => {
            currentColor = color;
            document.getElementById('color-picker').value = color;
          });
          paletteContainer.appendChild(colorDiv);
        });
      }
    }
    
    // Undo/redo functions
    function saveToUndoStack() {
      // Save a deep copy of the current frame
      undoStack.push({
        frame: [...frames[currentFrame]],
        frameIndex: currentFrame
      });
      redoStack = []; // Clear redo stack on new action
    }
    
    function undo() {
      if (undoStack.length === 0) return;
      
      const state = undoStack.pop();
      redoStack.push({
        frame: [...frames[state.frameIndex]],
        frameIndex: state.frameIndex
      });
      
      frames[state.frameIndex] = state.frame;
      currentFrame = state.frameIndex;
      drawCurrentFrame();
      updateTimeline();
    }
    
    function redo() {
      if (redoStack.length === 0) return;
      
      const state = redoStack.pop();
      undoStack.push({
        frame: [...frames[state.frameIndex]],
        frameIndex: state.frameIndex
      });
      
      frames[state.frameIndex] = state.frame;
      currentFrame = state.frameIndex;
      drawCurrentFrame();
      updateTimeline();
    }
    
    // Animation timeline
    function updateTimeline() {
      const timeline = document.getElementById('animation-timeline');
      timeline.innerHTML = '';
      
      frames.forEach((frame, index) => {
        const frameCanvas = document.createElement('canvas');
        frameCanvas.width = 60;
        frameCanvas.height = 60;
        frameCanvas.className = 'animation-frame';
        
        const frameCtx = frameCanvas.getContext('2d');
        const miniCellSize = frameCanvas.width / gridSize;
        
        // Draw frame preview
        frame.forEach((color, i) => {
          if (color !== '#FFFFFF') {
            const x = i % gridSize;
            const y = Math.floor(i / gridSize);
            frameCtx.fillStyle = color;
            frameCtx.fillRect(x * miniCellSize, y * miniCellSize, miniCellSize, miniCellSize);
          }
        });
        
        // Add border if current frame
        if (index === currentFrame) {
          frameCanvas.style.borderColor = '#FF6B00';
        }
        
        frameCanvas.addEventListener('click', () => {
          currentFrame = index;
          drawCurrentFrame();
          updateTimeline();
        });
        
        timeline.appendChild(frameCanvas);
      });
    }
    
    // Export functions
    function exportPNG() {
      const exportCanvas = document.createElement('canvas');
      exportCanvas.width = gridSize * 10;
      exportCanvas.height = gridSize * 10;
      const exportCtx = exportCanvas.getContext('2d');
      
      // Draw at higher resolution
      frames[currentFrame].forEach((color, index) => {
        if (color !== '#FFFFFF') {
          const x = index % gridSize;
          const y = Math.floor(index / gridSize);
          exportCtx.fillStyle = color;
          exportCtx.fillRect(x * 10, y * 10, 10, 10);
        }
      });
      
      const link = document.createElement('a');
      link.download = 'pixel-art.png';
      link.href = exportCanvas.toDataURL('image/png');
      link.click();
    }
    
    async function exportGIF() {
      if (frames.length === 1) {
        alert('Add more frames to create an animation!');
        return;
      }
      
      alert('GIF export requires FFmpeg.wasm - loading now (may take a moment)...');
      
      // Dynamically load FFmpeg
      const { createFFmpeg, fetchFile } = FFmpeg;
      const ffmpeg = createFFmpeg({ log: true });
      await ffmpeg.load();
      
      // Create PNG frames
      for (let i = 0; i < frames.length; i++) {
        const frameCanvas = document.createElement('canvas');
        frameCanvas.width = gridSize * 10;
        frameCanvas.height = gridSize * 10;
        const frameCtx = frameCanvas.getContext('2d');
        
        frames[i].forEach((color, index) => {
          if (color !== '#FFFFFF') {
            const x = index % gridSize;
            const y = Math.floor(index / gridSize);
            frameCtx.fillStyle = color;
            frameCtx.fillRect(x * 10, y * 10, 10, 10);
          }
        });
        
        const frameData = await fetchFile(frameCanvas.toDataURL('image/png'));
        ffmpeg.FS('writeFile', `frame${i}.png`, frameData);
      }
      
      // Run FFmpeg command
      await ffmpeg.run(
        '-framerate', '5',
        '-i', 'frame%d.png',
        '-f', 'gif',
        'output.gif'
      );
      
      // Download result
      const data = ffmpeg.FS('readFile', 'output.gif');
      const url = URL.createObjectURL(new Blob([data.buffer], { type: 'image/gif' }));
      const link = document.createElement('a');
      link.href = url;
      link.download = 'pixel-art.gif';
      link.click();
    }
    
    // Console attribution
    console.log('%câœ¨ Pixel Art Creator by Jv Shah (@JvShah124)', 'color: #FF6B00; font-size: 16px');
  </script>
  
  <!-- Load FFmpeg for GIF export (optional) -->
  <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js"></script>
</body>
</html>
