<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pixel Art Creator | Built by Jv Shah</title>
  <style>
    body {
      font-family: 'Courier New', monospace;
      background: #f0f0f0;
      margin: 0;
      padding: 20px;
      text-align: center;
    }
    
    h1 {
      color: #333;
    }
    
    #toolbar {
      margin: 20px auto;
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    button, select, input {
      padding: 8px 12px;
      background: white;
      border: 2px solid #333;
      font-family: inherit;
      cursor: pointer;
    }
    
    button:hover {
      background: #333;
      color: white;
    }
    
    #color-picker {
      width: 50px;
      height: 30px;
      padding: 0;
      border: 2px solid #333;
    }
    
    #canvas-container {
      margin: 0 auto;
      display: inline-block;
      background: white;
      box-shadow: 0 0 10px rgba(0,0,0,0.2);
      position: relative;
    }
    
    #pixel-canvas {
      display: block;
      image-rendering: pixelated;
      cursor: crosshair;
    }
    
    #animation-timeline {
      margin: 20px auto;
      display: flex;
      overflow-x: auto;
      gap: 5px;
      max-width: 800px;
    }
    
    .animation-frame {
      border: 2px solid #333;
      background: white;
    }
    
    .copyright {
      position: fixed;
      bottom: 12px;
      right: 12px;
      font-family: monospace;
      color: #666;
      background: rgba(255, 255, 255, 0.7);
      padding: 4px 8px;
      border-radius: 4px;
    }
    
    .copyright a {
      color: #FF6B00;
      text-decoration: none;
    }
    
    .copyright a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <h1>Pixel Art Creator</h1>
  
  <div id="toolbar">
    <select id="grid-size">
      <option value="8">8x8</option>
      <option value="16" selected>16x16</option>
      <option value="32">32x32</option>
      <option value="64">64x64</option>
    </select>
    
    <input type="color" id="color-picker" value="#FF0000">
    
    <select id="tool-select">
      <option value="pencil" selected>Pencil</option>
      <option value="fill">Fill</option>
      <option value="erase">Erase</option>
    </select>
    
    <button id="clear-btn">Clear</button>
    <button id="add-frame-btn">Add Frame</button>
    <button id="export-png-btn">Export PNG</button>
    <button id="export-gif-btn">Export GIF</button>
  </div>
  
  <div id="canvas-container">
    <canvas id="pixel-canvas" width="320" height="320"></canvas>
  </div>
  
  <div id="animation-timeline"></div>
  
  <footer class="copyright">
    Built by <a href="https://x.com/JvShah124" target="_blank" rel="noopener">Jv Shah</a>
  </footer>

  <script>
    // Core variables
    const canvas = document.getElementById('pixel-canvas');
    const ctx = canvas.getContext('2d');
    let currentColor = '#FF0000';
    let currentTool = 'pencil';
    let gridSize = 16;
    let cellSize = canvas.width / gridSize;
    let frames = [];
    let currentFrame = 0;
    
    // Initialize
    initCanvas();
    
    // Event listeners
    document.getElementById('color-picker').addEventListener('input', (e) => {
      currentColor = e.target.value;
    });
    
    document.getElementById('tool-select').addEventListener('change', (e) => {
      currentTool = e.target.value;
    });
    
    document.getElementById('grid-size').addEventListener('change', (e) => {
      gridSize = parseInt(e.target.value);
      cellSize = canvas.width / gridSize;
      initCanvas();
    });
    
    document.getElementById('clear-btn').addEventListener('click', () => {
      frames[currentFrame] = createBlankFrame();
      drawCurrentFrame();
    });
    
    document.getElementById('add-frame-btn').addEventListener('click', () => {
      frames.push(createBlankFrame());
      currentFrame = frames.length - 1;
      updateTimeline();
      drawCurrentFrame();
    });
    
    document.getElementById('export-png-btn').addEventListener('click', exportPNG);
    document.getElementById('export-gif-btn').addEventListener('click', exportGIF);
    
    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseout', stopDrawing);
    
    // Core functions
    function initCanvas() {
      frames = [createBlankFrame()];
      currentFrame = 0;
      drawCurrentFrame();
      updateTimeline();
    }
    
    function createBlankFrame() {
      const frame = [];
      for (let i = 0; i < gridSize * gridSize; i++) {
        frame.push('#FFFFFF');
      }
      return frame;
    }
    
    function drawCurrentFrame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw grid
      ctx.strokeStyle = '#EEE';
      ctx.lineWidth = 1;
      
      for (let x = 0; x <= gridSize; x++) {
        ctx.beginPath();
        ctx.moveTo(x * cellSize, 0);
        ctx.lineTo(x * cellSize, canvas.height);
        ctx.stroke();
      }
      
      for (let y = 0; y <= gridSize; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * cellSize);
        ctx.lineTo(canvas.width, y * cellSize);
        ctx.stroke();
      }
      
      // Draw pixels
      frames[currentFrame].forEach((color, index) => {
        if (color !== '#FFFFFF') {
          const x = index % gridSize;
          const y = Math.floor(index / gridSize);
          ctx.fillStyle = color;
          ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
        }
      });
    }
    
    // Drawing logic
    let isDrawing = false;
    
    function startDrawing(e) {
      isDrawing = true;
      draw(e);
    }
    
    function draw(e) {
      if (!isDrawing) return;
      
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / cellSize);
      const y = Math.floor((e.clientY - rect.top) / cellSize);
      
      if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
        const index = y * gridSize + x;
        
        switch (currentTool) {
          case 'pencil':
            frames[currentFrame][index] = currentColor;
            break;
          case 'erase':
            frames[currentFrame][index] = '#FFFFFF';
            break;
          case 'fill':
            floodFill(x, y, frames[currentFrame][index], currentColor);
            break;
        }
        
        drawCurrentFrame();
      }
    }
    
    function stopDrawing() {
      isDrawing = false;
    }
    
    // Flood fill algorithm
    function floodFill(x, y, targetColor, replacementColor) {
      if (targetColor === replacementColor) return;
      
      const index = y * gridSize + x;
      if (frames[currentFrame][index] !== targetColor) return;
      
      frames[currentFrame][index] = replacementColor;
      
      if (x > 0) floodFill(x - 1, y, targetColor, replacementColor);
      if (x < gridSize - 1) floodFill(x + 1, y, targetColor, replacementColor);
      if (y > 0) floodFill(x, y - 1, targetColor, replacementColor);
      if (y < gridSize - 1) floodFill(x, y + 1, targetColor, replacementColor);
    }
    
    // Animation timeline
    function updateTimeline() {
      const timeline = document.getElementById('animation-timeline');
      timeline.innerHTML = '';
      
      frames.forEach((frame, index) => {
        const frameCanvas = document.createElement('canvas');
        frameCanvas.width = 60;
        frameCanvas.height = 60;
        frameCanvas.className = 'animation-frame';
        
        const frameCtx = frameCanvas.getContext('2d');
        const miniCellSize = frameCanvas.width / gridSize;
        
        // Draw frame preview
        frame.forEach((color, i) => {
          if (color !== '#FFFFFF') {
            const x = i % gridSize;
            const y = Math.floor(i / gridSize);
            frameCtx.fillStyle = color;
            frameCtx.fillRect(x * miniCellSize, y * miniCellSize, miniCellSize, miniCellSize);
          }
        });
        
        // Add border if current frame
        if (index === currentFrame) {
          frameCanvas.style.borderColor = '#FF6B00';
        }
        
        frameCanvas.addEventListener('click', () => {
          currentFrame = index;
          drawCurrentFrame();
          updateTimeline();
        });
        
        timeline.appendChild(frameCanvas);
      });
    }
    
    // Export functions
    function exportPNG() {
      const exportCanvas = document.createElement('canvas');
      exportCanvas.width = gridSize * 10;
      exportCanvas.height = gridSize * 10;
      const exportCtx = exportCanvas.getContext('2d');
      
      // Draw at higher resolution
      frames[currentFrame].forEach((color, index) => {
        if (color !== '#FFFFFF') {
          const x = index % gridSize;
          const y = Math.floor(index / gridSize);
          exportCtx.fillStyle = color;
          exportCtx.fillRect(x * 10, y * 10, 10, 10);
        }
      });
      
      const link = document.createElement('a');
      link.download = 'pixel-art.png';
      link.href = exportCanvas.toDataURL('image/png');
      link.click();
    }
    
    async function exportGIF() {
      if (frames.length === 1) {
        alert('Add more frames to create an animation!');
        return;
      }
      
      alert('GIF export requires FFmpeg.wasm - loading now (may take a moment)...');
      
      // Dynamically load FFmpeg
      const { createFFmpeg, fetchFile } = FFmpeg;
      const ffmpeg = createFFmpeg({ log: true });
      await ffmpeg.load();
      
      // Create PNG frames
      for (let i = 0; i < frames.length; i++) {
        const frameCanvas = document.createElement('canvas');
        frameCanvas.width = gridSize * 10;
        frameCanvas.height = gridSize * 10;
        const frameCtx = frameCanvas.getContext('2d');
        
        frames[i].forEach((color, index) => {
          if (color !== '#FFFFFF') {
            const x = index % gridSize;
            const y = Math.floor(index / gridSize);
            frameCtx.fillStyle = color;
            frameCtx.fillRect(x * 10, y * 10, 10, 10);
          }
        });
        
        const frameData = await fetchFile(frameCanvas.toDataURL('image/png'));
        ffmpeg.FS('writeFile', `frame${i}.png`, frameData);
      }
      
      // Run FFmpeg command
      await ffmpeg.run(
        '-framerate', '5',
        '-i', 'frame%d.png',
        '-f', 'gif',
        'output.gif'
      );
      
      // Download result
      const data = ffmpeg.FS('readFile', 'output.gif');
      const url = URL.createObjectURL(new Blob([data.buffer], { type: 'image/gif' }));
      const link = document.createElement('a');
      link.href = url;
      link.download = 'pixel-art.gif';
      link.click();
    }
    
    // Console attribution
    console.log('%câœ¨ Pixel Art Creator by Jv Shah (@JvShah124)', 'color: #FF6B00; font-size: 16px');
  </script>
  
  <!-- Load FFmpeg for GIF export (optional) -->
  <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js"></script>
</body>
</html>
